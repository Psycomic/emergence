(do
	(comptime
	 (set-macro! (quote macro)
				 (named-lambda macro (name args body)
							   (list (quote comptime)
									 (list (quote set-macro!)
										   (list (quote quote) name)
										   (list (quote named-lambda)
												 name
												 args
												 body))))))

	(macro func (name args . body)
		   (list (quote do)
				 (list (quote comptime)
					   (list (quote register-function!)
							 (list (quote quote) name)
							 (lambda-list-length args)))
				 (list (quote set-global!)
					   (list (quote quote) name)
					   (append (list (quote named-lambda)
									 name args)
							    body))
				 (list (quote quote) name)))

  (comptime
   (func cond-helper (clauses)
		 (if (null? clauses)
			 nil
			 (let ((c (head clauses)))
			   (list (quote if) (head c)
					 (second c)
					 (cond-helper (tail clauses))))))

   (func map-helper (fn lst acc)
		 (if (null? lst)
			 (reverse! acc)
			 (map-helper fn (tail lst)
						 (: (fn (head lst)) acc))))

   (func map (fn lst)
		 "Applies the function `fn' to every element in lst
and returns a list containing the results"
		 (map-helper fn lst nil))

   (func quasiquote-helper (expression)
		 (if (list? expression)
			 (if (eq? (head expression) (quote unquote))
				 (second expression)
				 (if (null? expression)
					 nil
					 (: (quote list)
						(map quasiquote-helper expression))))
			 (list (quote quote) expression))))

  (macro quasiquote (expression)
		 (quasiquote-helper expression))

  (macro cond clauses
		 (cond-helper clauses))

  (macro lambda (args . body)
		 (append (list (quote named-lambda)
					   (quote anon)
					   args)
				 body))

  (macro and (a b)
		 (quasiquote
		  (if (unquote a) (unquote b) nil)))

  (macro when (condition . body)
		 (list (quote if) condition
			   (append (list (quote do)) body)
			   nil))

  (macro define (symbol value)
		 (quasiquote
		  (do (comptime (register-global! (quote (unquote symbol))))
			  (set-global! (quote (unquote symbol)) (unquote value)))))

  (func range-helper (max acc)
		(if (= max 0)
			(: max acc)
			(range-helper (- max 1)
						  (: max acc))))

  (func range (x)
		"Return a list containing every number between 0 and `x' (included)"
		(range-helper x nil))

  (func assert-fn (value error)
		(if value value
			(invoke-debugger (quote assertion-error))))

  (macro assert (value)
		 (quasiquote
		  (assert-fn (unquote value)
					 (quote (unquote value)))))

  (define pi 3.1415)

  (assert (= 5 5))
  (assert (= 5.0 5))
  (assert (= 5 5.0))
  (assert (= 5.0 5.0))

  (assert (> 4.5 2))
  (assert (> 6 3.2))
  (assert (> 6 5))
  (assert (> 6.5 5.5))

  (assert (< 2 4.5))
  (assert (< 3 6.2))
  (assert (< 5 6))
  (assert (< 5.5 6.5))

  (macro for (e lst . body)
		 (let ((list-sym (gensym))
			   (cont-sym (gensym)))
		   (quasiquote
			(let (((unquote list-sym) (unquote lst)))
			  (with-cont (unquote cont-sym)
						 (with-cont nil
									(loop
									 (if (null? (tail (unquote list-sym)))
										 (exit (unquote cont-sym) nil)
										 (do (let (((unquote e) (head (unquote list-sym))))
											   (unquote (head body)))
											 (set! (unquote list-sym)
												   (tail (unquote list-sym))))))))))))

  (macro times (i count . body)
		 (let ((count-sym (gensym))
			   (cont-sym (gensym)))
		   (quasiquote
			(let (((unquote i) 0)
				  ((unquote count-sym) (unquote count)))
			  (with-cont (unquote cont-sym)
						 (loop (if (>= (unquote i) (unquote count-sym))
								   (exit (unquote cont-sym) (unquote i))
								   (do (unquote (head body))
									   (set! (unquote i)
											 (+ (unquote i) 1))))))))))

  (macro while (condition body)
		 (let ((cont-sym (gensym)))
		   (quasiquote
			(with-cont (unquote cont-sym)
					   (loop
						(if (unquote condition)
							(unquote body)
							(exit (unquote cont-sym) nil)))))))

  (func 1+ (x) "Add one to `x'" (+ x 1))
  (func 1- (x) "Substract one to `x'" (- x 1))

(func search (lst element key)
		(cond ((null? lst) nil)
			  ((eq? (key (first lst)) element)
			   (first lst))
			  (t (search (tail lst) element key))))

  (func make-board (size)
		"Makes a Game of Life board of size `size'"
		(let ((board (make-array (* size size) 0)))
		  (board-set! board size 1 0 1)
		  (board-set! board size 2 1 1)
		  (board-set! board size 0 2 1)
		  (board-set! board size 1 2 1)
		  (board-set! board size 2 2 1)
		  board))

  (func board-get (board size x y)
		"Get the cell in position (x, y)"
		(aref board (+ (* x size) y)))

  (func board-set! (board size x y val)
		"Set the cell in position (x, y) to `val'"
		(aset! board (+ (* x size) y) val))

  (func neighbors (board size x y)
		"Returns the numbers of neighbors in position (x, y)"
		(+ (board-get board size (mod (1+ x) size) y)
		   (board-get board size (mod (1+ x) size) (mod (1+ y) size))
		   (board-get board size (mod (1+ x) size) (mod (1- y) size))
		   (board-get board size (mod (1- x) size) y)
		   (board-get board size (mod (1- x) size) (mod (1+ y) size))
		   (board-get board size (mod (1- x) size) (mod (1- y) size))
		   (board-get board size x (mod (1+ y) size))
		   (board-get board size x (mod (1- y) size))))

  (func next-board (board size)
		"Returns the next step in the game of life"
		(let ((new-board (make-array (* size size) 0)))
		  (times x size
				 (times y size
						(let ((c (board-get board size x y))
							  (n (neighbors board size x y)))
						  (board-set! new-board size x y
									  (if (= c 1)
										  (cond ((= n 2) 1)
												((= n 3) 1)
												(t 0))
										  (if (= n 3) 1 0))))))
		  new-board))

  (define *board* (make-board 10))

  (func next-step ()
		(set! *board* (next-board *board* 10)))

  (func benchmark ()
		(let ((t1 (clock)))
		  (times i 500 (next-step))
		  (- (clock) t1)))

  (func stream-test ()
		(let ((out (make-string-output-stream)))
		  (write-char! out 65)
		  (write-char! out 54)
		  (write-char! out 10)
		  (write-char! out 12405)
		  (write-char! out 10)
		  (let ((result (stream-string out)))
			(stream-close out)
			result)))

  (func output-test ()
		(let ((ss (make-string-output-stream)))
		  (dynamic-let ((*output* ss))
					   (print (quote (hello world))))
		  (stream-string ss)))

  (func make-person (name age)
		(lambda (msg . args)
		  (cond ((eq? msg (quote get-name)) name)
				((eq? msg (quote set-name))
				 (set! name (head args)))
				((eq? msg (quote get-age)) age)
				((eq? msg (quote set-age))
				 (set! age (head args)))
				(t (quote message-not-understood)))))

  (define ewen (make-person "Ewen" 16))

  (define Y                 ; (Y f) = (g g) where
	(lambda (f)             ;         (g g) = (f  (lambda a (apply (g g) a)))
      ((lambda (g) (g g))   ; (Y f) ==        (f  (lambda a (apply (Y f) a)))
       (lambda (g)
		 (f (lambda (a) ((g g) a)))))))

  (define fact
	(Y (lambda (r)
		 (lambda (x)
		   (if (< x 2) 1
			   (* x (r (- x 1))))))))

  (func test-closure-cont ()
		(let ((i 0)
			  (fn nil))
		  (with-cont c
					 (let ((a (lambda (x)
								(if (> x (+ i 5))
									(exit c 5)
									nil))))
					   (set! fn a)
					   (loop
						(a i)
						(set! i (1+ i)))))
		  (list i fn)))

  (define *handler-clusters* nil)

  (macro handler-bind (bindings . forms)
		 (let ((make-binding
				(lambda (binding)
				  (quasiquote
				   (list (quote (unquote (first binding)))
						 (unquote (second binding)))))))
		   (let ((cluster (map make-binding bindings)))
			 (append (list (quote dynamic-let)
						   (list (list (quote *handler-clusters*)
									   (list (quote append)
											 (append (list (quote list))
													 cluster)
											 (quote *handler-clusters*)))))
					 forms))))

  (macro handler-case (form . cases)
		 (let ((cont-sym (gensym)))
		   (let ((make-binding
				  (lambda (binding)
					(list (first binding)
						  (append (list (quote lambda) (second binding))
								  (list (list (quote exit) cont-sym
											  (append (list (quote do))
													  (tail (tail binding))))))))))
			 (list (quote with-cont) cont-sym
				   (list (quote handler-bind)
						 (map make-binding cases)
						 form)))))

  (func error (type . args)
		(let ((handler (search *handler-clusters* type first)))
		  (if handler
			  ((second handler) args)
			  (invoke-debugger type))))

  (func divide (a b)
		(if (= b 0)
			(error (quote division-by-zero) nil)
			(/ a b)))

  (func test-errors (x)
		(handler-bind ((division-by-zero
						(lambda (args)
						  (print "Division by zero occured!")
						  (quote division-by-zero))))
					  (print *handler-clusters*)
					  (divide 10 x))))
