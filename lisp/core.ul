(begin
  (def list (n-lambda list args args))

  (def null? (n-lambda null? (x) (if x nil t)))

  (def append
	   (n-lambda append (a b)
				 (if (null? a)
					 b
					 (if (null? b)
						 a
						 (cons (car a)
							   (append (cdr a) b))))))

  (def-macro lambda
	(n-lambda lambda (args . body)
			  (append (list (quote n-lambda) (quote anonymous-closure)
							args)
					  body)))

  (def-macro defun
	(n-lambda defun (name lambda-list . body)
	  (list (quote def) name
			(append (list (quote n-lambda) name lambda-list)
					body))))

  (def-macro defmacro
	(n-lambda defmacro (name lambda-list . body)
	  (list (quote def-macro) name
			(append (list (quote n-lambda) name lambda-list)
					body))))

  (defun map (fn lst)
	(if (null? lst)
		nil
		(cons (fn (car lst))
			  (map fn (cdr lst)))))

  (defun cond-helper (clauses)
	(let ((c (car clauses)))
	  (if (null? (cdr clauses))
		  (list (quote if) (car c)
				(car (cdr c)))
		  (list (quote if) (car c)
				(car (cdr c))
				(cond-helper (cdr clauses))))))

  (defun cadr (pair)
	(car (cdr pair)))

  (defmacro cond clauses
	(cond-helper clauses))

  (defmacro letrec (bindings . body)
	(append (append
			 (list (quote let)
				   (map (lambda (b)
						  (list (car b) nil))
						bindings))
			 (map (lambda (b)
					(list (quote set!) (car b) (car (cdr b))))
				  bindings))
			body))

  (defmacro n-let (name bindings . body)
	(list (quote letrec)
		  (list (list name
					  (append (list (quote lambda) (map car bindings))
							  body)))
		  (cons name (map cadr bindings))))

  (defmacro or clauses
	(letrec ((or-helper
			  (lambda (clauses)
				(if (null? clauses)
					nil
					(list (quote if) (car clauses)
						  t
						  (or-helper (cdr clauses)))))))
	  (or-helper clauses)))

  (defmacro and (a b)
	(list (quote if) a
		  (list (quote if) b
				t)))

  (defmacro dotimes (var times . body)
	(list (quote n-let) (quote loop) (list (list var 0))
		  (list (quote if) (list (quote <) var times)
				(cons (quote begin)
					  (append body (list (list (quote loop) (list (quote 1+) var)))))
				var)))

  (defun 1+ (x)
	(+ x 1))

  (defun 1- (x)
	(- x 1))

  (defun ! (x)
	(if (< x 1)
		1
		(* x (! (1- x)))))

  (defun range (min max)
	(if (> min max)
		nil
		(cons min (range (1+ min) max))))

  (defun fizzbuzz-helper (n max)
	(if (> n max)
		nil
		(cons (if (= (mod n 3) 0)
				  (if (= (mod n 5) 0)
					  (quote fizzbuzz)
					  (quote fizz))
				  (if (= (mod n 5) 0)
					  (quote buzz)
					  n))
			  (fizzbuzz-helper (1+ n) max))))

  (defun fizzbuzz (max)
	(fizzbuzz-helper 0 max))

  (defun sqrt-iter (guess x)
	(if (good-enough? guess x)
		guess
		(sqrt-iter (improve guess x) x)))

  (defun improve (guess x)
	(average guess (/ x guess)))

  (defun average (x y)
	(/ (+ x y) 2))

  (defun good-enough? (guess x)
	(< (abs (- (square guess) x)) 0.00001))

  (defun abs (x)
	(if (< x 0.0)
		(- x) x))

  (defun square (x)
	(* x x))

  (defun sqrt (x)
	(sqrt-iter 1.0 x))

  (defun nth-helper (lst n i)
	(if (= n i)
		(car lst)
		(nth-helper (cdr lst) n (1+ i))))

  (defun nth (lst n)
	(nth-helper lst n 0))

  (defun product (lst)
	(if (cons? lst)
		(if (null? (cdr lst))
			(car lst)
			(* (car lst) (product (cdr lst))))
		lst))

  (defun array-flatten (arr)
	(make-array (array-total-size arr) nil arr))

  (defun array-map (fn arr)
	(let ((dims (array-total-size arr))
		  (flat-arr (array-flatten arr))
		  (new-array (make-array (array-dimensions arr) nil)))
	  (let ((flat-new-array (array-flatten new-array)))
		(n-let loop ((i 0))
			   (if (< i dims)
				   (begin (array-set! flat-new-array
									  (fn (array-ref flat-arr i))
									  i)
						  (loop (1+ i)))
				   new-array)))))

  (defun make-board (dims)
	(array-map (lambda (x) (random 2))
			   (make-array dims nil)))

  (def *board* (make-board (quote (10 10))))

  (defun board-get (board x y)
	(if (or (< x 0) (< y 0)
			(> x 9) (> y 9))
		0
		(array-ref board x y)))

  (defun board-set! (board x y val)
	(array-set! board val x y))

  (defun neightbors (board x y)
	(+ (board-get board (1- x) y)
	   (board-get board (1+ x) y)
	   (board-get board x (1- y))
	   (board-get board x (1+ y))
	   (board-get board (1- x) (1- y))
	   (board-get board (1+ x) (1- y))
	   (board-get board (1- x) (1+ y))
	   (board-get board (1+ x) (1+ y))))

  (defun next-life (board)
	(let ((new-board (make-array (array-dimensions board) 0)))
	  (dotimes x 10
			   (dotimes y 10
						(let ((c (board-get board x y))
							  (n (neightbors board x y)))
						  (if (and (= c 1) (or (= n 2) (= n 3)))
							  (board-set! new-board x y 1))
						  (if (and (= c 0) (= n 3))
							  (board-set! new-board x y 1)))))
	  new-board))

  (defun next ()
	(set! *board* (next-life *board*))
	*board*)

  (defmacro macro-error ()
	(throw (quote error)))

  (defun current-continuation ()
	(call/cc (lambda (cc) (cc cc))))

  (defun try-fn (fn catch-fn)
	(let ((cc (current-continuation)))
	  (if (continuation? cc)
		  (begin (set! exception-stack
					   (cons cc exception-stack))
				 (fn))
		  (catch-fn))))

  (defmacro try (form . catched)
	(list try-fn (list (quote lambda) nil form)
		  (append (list (quote lambda) nil) catched)))

  (defun make-lambda (args body env)
	(list args body env))

  (defun lambda-args (l)
	(car l))

  (defun lambda-body (l)
	(car (cdr l)))

  (defun lambda-env (l)
	(car (cdr (cdr l))))

  (defun assoc (s env)
	(if (eq? s (car (car env)))
		(cdr (car env))
		(assoc s (cdr env))))

  (defun extend-environnement (env bindings values)
	(if (null? bindings)
		env
		(extend-environnement (cons (cons (car bindings)
										  (car values))
									env)
							  (cdr bindings)
							  (cdr values))))

  (defun begins-with? (e s)
	(eq? (car e) s))

  (defun eval (e v)
	(cond ((symbol? e) (assoc e v))
		  ((begins-with? e (quote q))
		   (car (cdr e)))
		  ((begins-with? e (quote l))
		   (make-lambda (car (cdr e))
						(car (cdr (cdr e)))
						v))
		  (t (let ((forms (map eval e)))
			   (eval (lambda-body (car forms))
					 (extend-environnement (lambda-env (car forms))
										   (lambda-args (car forms))
										   (cdr forms))))))))
