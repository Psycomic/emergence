(begin
  (def list (n-lambda list args args))

  (def null? (n-lambda null? (x) (if x nil t)))

  (def append
	   (n-lambda append (a b)
				 (if (null? a)
					 b
					 (if (null? b)
						 a
						 (cons (car a)
							   (append (cdr a) b))))))

  (def-macro lambda
	(n-lambda lambda (args . body)
			  (append (list (quote n-lambda) (quote anonymous-closure)
							args)
					  body)))

  (def-macro defun
	(n-lambda defun (name lambda-list . body)
	  (list (quote def) name
			(append (list (quote n-lambda) name lambda-list)
					body))))

  (def-macro defmacro
	(n-lambda defmacro (name lambda-list . body)
	  (list (quote def-macro) name
			(append (list (quote n-lambda) name lambda-list)
					body))))

  (defun map (fn lst)
	(if (null? lst)
		nil
		(cons (fn (car lst))
			  (map fn (cdr lst)))))

  (defmacro let (bindings . body)
	(append (list (append (list (quote lambda) (map car bindings))
						  body))
			(map (lambda (x) (car (cdr x))) bindings)))

  (defun cond-helper (clauses)
	(let ((c (car clauses)))
	  (if (null? (cdr clauses))
		  (list (quote if) (car c)
				(car (cdr c)))
		  (list (quote if) (car c)
				(car (cdr c))
				(cond-helper (cdr clauses))))))

  (defmacro cond clauses
	(cond-helper clauses))

  (defun 1+ (x)
	(+ x 1))

  (defun 1- (x)
	(- x 1))

  (defun ! (x)
	(if (< x 1)
		1
		(* x (! (1- x)))))

  (defun range (min max)
	(if (> min max)
		nil
		(cons min (range (1+ min) max))))

  (defun fizzbuzz-helper (n max)
	(if (> n max)
		nil
		(cons (if (= (mod n 3) 0)
				  (if (= (mod n 5) 0)
					  (quote fizzbuzz)
					  (quote fizz))
				  (if (= (mod n 5) 0)
					  (quote buzz)
					  n))
			  (fizzbuzz-helper (1+ n) max))))

  (defun fizzbuzz (max)
	(fizzbuzz-helper 0 max))

  (defun sqrt-iter (guess x)
	(if (good-enough? guess x)
		guess
		(sqrt-iter (improve guess x) x)))

  (defun improve (guess x)
	(average guess (/ x guess)))

  (defun average (x y)
	(/ (+ x y) 2))

  (defun good-enough? (guess x)
	(< (abs (- (square guess) x)) 0.00001))

  (defun abs (x)
	(if (< x 0.0)
		(- y) x))

  (defun square (x)
	(* x x))

  (defun sqrt (x)
	(sqrt-iter 1.0 x))

  (defun nth-helper (lst n i)
	(if (= n i)
		(car lst)
		(nth-helper (cdr lst) n (1+ i))))

  (defun nth (lst n)
	(nth-helper lst n 0))

  (defun make-board (dims)
	(cond ((null? dims) nil)
		  ((cons? dims)
		   (cons (make-board (car dims))
				 (make-board (cdr dims))))
		  ((= dims 0) nil)
		  (t (cons (random 2)
				   (make-board (1- dims))))))

  (def *board* (make-board (quote (10 10))))

  (defun board-get (x y)
	(nth (nth *board* y) x)))
